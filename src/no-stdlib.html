<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Без stdlib</title>

    <link rel="stylesheet" type="text/css" href="../rust-book.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    <div id="nav">
                <button id="toggle-nav">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                  <span class="bar"></span>
                </button>
              </div>
<div id='toc' class='mobile-hidden'>
<ul class='chapter'>
<li><a  href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='../src/INTRODUCTION.html'><b>2.</b> Введение</a>
</li>
<li><a  href='../src/getting-started.html'><b>3.</b> C чего начать</a>
</li>
<li><a  href='../src/learn-rust.html'><b>4.</b> Изучение Rust</a>
<ul class='section'>
<li><a  href='../src/guessing-game.html'><b>4.1.</b> Угадайка</a>
</li>
<li><a  href='../src/dining-philosophers.html'><b>4.2.</b> Обедающие философы</a>
</li>
<li><a  href='../src/rust-inside-other-languages.html'><b>4.3.</b> Вызов кода на Rust из других языков</a>
</li>
</ul>
</li>
<li><a  href='../src/effective-rust.html'><b>5.</b> Эффективное использование Rust</a>
<ul class='section'>
<li><a  href='../src/the-stack-and-the-heap.html'><b>5.1.</b> Стек и куча</a>
</li>
<li><a  href='../src/testing.html'><b>5.2.</b> Тестирование</a>
</li>
<li><a  href='../src/conditional-compilation.html'><b>5.3.</b> Условная компиляция</a>
</li>
<li><a  href='../src/documentation.html'><b>5.4.</b> Документация</a>
</li>
<li><a  href='../src/iterators.html'><b>5.5.</b> Итераторы</a>
</li>
<li><a  href='../src/concurrency.html'><b>5.6.</b> Многозадачность</a>
</li>
<li><a  href='../src/error-handling.html'><b>5.7.</b> Обработка ошибок</a>
</li>
<li><a  href='../src/choosing-your-guarantees.html'><b>5.8.</b> Выбор гарантий</a>
</li>
<li><a  href='../src/ffi.html'><b>5.9.</b> Интерфейс внешних функций (FFI)</a>
</li>
<li><a  href='../src/borrow-and-asref.html'><b>5.10.</b> Типажи `Borrow` и `AsRef`</a>
</li>
<li><a  href='../src/release-channels.html'><b>5.11.</b> Каналы сборок</a>
</li>
</ul>
</li>
<li><a  href='../src/syntax-and-semantics.html'><b>6.</b> Синтаксис и семантика</a>
<ul class='section'>
<li><a  href='../src/variable-bindings.html'><b>6.1.</b> Связывание имён</a>
</li>
<li><a  href='../src/functions.html'><b>6.2.</b> Функции</a>
</li>
<li><a  href='../src/primitive-types.html'><b>6.3.</b> Простые типы</a>
</li>
<li><a  href='../src/comments.html'><b>6.4.</b> Комментарии</a>
</li>
<li><a  href='../src/if.html'><b>6.5.</b> Конструкция `if`</a>
</li>
<li><a  href='../src/loops.html'><b>6.6.</b> Циклы</a>
</li>
<li><a  href='../src/ownership.html'><b>6.7.</b> Владение</a>
</li>
<li><a  href='../src/references-and-borrowing.html'><b>6.8.</b> Ссылки и заимствование</a>
</li>
<li><a  href='../src/lifetimes.html'><b>6.9.</b> Время жизни</a>
</li>
<li><a  href='../src/mutability.html'><b>6.10.</b> Изменяемость (mutability)</a>
</li>
<li><a  href='../src/structs.html'><b>6.11.</b> Структуры</a>
</li>
<li><a  href='../src/enums.html'><b>6.12.</b> Перечисления</a>
</li>
<li><a  href='../src/match.html'><b>6.13.</b> Конструкция `match`</a>
</li>
<li><a  href='../src/patterns.html'><b>6.14.</b> Шаблоны сопоставления `match`</a>
</li>
<li><a  href='../src/method-syntax.html'><b>6.15.</b> Синтаксис методов</a>
</li>
<li><a  href='../src/vectors.html'><b>6.16.</b> Вектора</a>
</li>
<li><a  href='../src/strings.html'><b>6.17.</b> Строки</a>
</li>
<li><a  href='../src/generics.html'><b>6.18.</b> Обобщённое программирование</a>
</li>
<li><a  href='../src/traits.html'><b>6.19.</b> Типажи</a>
</li>
<li><a  href='../src/drop.html'><b>6.20.</b> Типаж `Drop` (сброс)</a>
</li>
<li><a  href='../src/if-let.html'><b>6.21.</b> Конструкция `if let`</a>
</li>
<li><a  href='../src/trait-objects.html'><b>6.22.</b> Типажи-объекты</a>
</li>
<li><a  href='../src/closures.html'><b>6.23.</b> Замыкания</a>
</li>
<li><a  href='../src/ufcs.html'><b>6.24.</b> Универсальный синтаксис вызова функций (UFCS)</a>
</li>
<li><a  href='../src/crates-and-modules.html'><b>6.25.</b> Контейнеры (crates) и модули (modules)</a>
</li>
<li><a  href='../src/const-and-static.html'><b>6.26.</b> `const` и `static`</a>
</li>
<li><a  href='../src/attributes.html'><b>6.27.</b> Атрибуты</a>
</li>
<li><a  href='../src/type-aliases.html'><b>6.28.</b> Псевдонимы типов</a>
</li>
<li><a  href='../src/casting-between-types.html'><b>6.29.</b> Приведение типов</a>
</li>
<li><a  href='../src/associated-types.html'><b>6.30.</b> Ассоциированные типы</a>
</li>
<li><a  href='../src/unsized-types.html'><b>6.31.</b> Безразмерные типы</a>
</li>
<li><a  href='../src/operators-and-overloading.html'><b>6.32.</b> Перегрузка операций</a>
</li>
<li><a  href='../src/deref-coercions.html'><b>6.33.</b> Преобразования при разыменовании (deref coercions)</a>
</li>
<li><a  href='../src/macros.html'><b>6.34.</b> Макросы</a>
</li>
<li><a  href='../src/raw-pointers.html'><b>6.35.</b> Сырые указатели</a>
</li>
<li><a  href='../src/unsafe.html'><b>6.36.</b> Небезопасный код</a>
</li>
</ul>
</li>
<li><a  href='../src/nightly-rust.html'><b>7.</b> Нестабильные возможности Rust</a>
<ul class='section'>
<li><a  href='../src/compiler-plugins.html'><b>7.1.</b> Плагины к компилятору</a>
</li>
<li><a  href='../src/inline-assembly.html'><b>7.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a class='active' href='../src/no-stdlib.html'><b>7.3.</b> Без stdlib</a>
</li>
<li><a  href='../src/intrinsics.html'><b>7.4.</b> Внутренние средства (intrinsics)</a>
</li>
<li><a  href='../src/lang-items.html'><b>7.5.</b> Элементы языка (lang items)</a>
</li>
<li><a  href='../src/advanced-linking.html'><b>7.6.</b> Продвинутое руководство по компоновке (advanced linking)</a>
</li>
<li><a  href='../src/benchmark-tests.html'><b>7.7.</b> Тесты производительности</a>
</li>
<li><a  href='../src/box-syntax-and-patterns.html'><b>7.8.</b> Синтаксис упаковки и шаблоны `match`</a>
</li>
<li><a  href='../src/slice-patterns.html'><b>7.9.</b> Шаблоны `match` для срезов</a>
</li>
<li><a  href='../src/associated-constants.html'><b>7.10.</b> Ассоциированные константы</a>
</li>
<li><a  href='../src/custom-allocators.html'><b>7.11.</b> Пользовательские менеджеры памяти</a>
</li>
</ul>
</li>
<li><a  href='../src/glossary.html'><b>8.</b> Глоссарий</a>
</li>
<li><a  href='../src/bibliography.html'><b>9.</b> Библиография</a>
</li>
</ul>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Без stdlib</h1>
    <p>По умолчанию, <code>std</code> компонуется с каждым контейнером Rust. В некоторых случаях это
нежелательно, и этого можно избежать с помощью атрибута <code>#![no_std]</code>,
примененного (привязанного) к контейнеру.</p>
<span class='rusttest'>// a minimal library
#![crate_type=&quot;lib&quot;]
#![feature(no_std)]
#![no_std]
// fn main() {} tricked you, rustdoc!
</span><pre class='rust rust-example-rendered'>
<span class='comment'>// a minimal library</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>crate_type</span><span class='op'>=</span><span class='string'>&quot;lib&quot;</span>]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>no_std</span>)]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>no_std</span>]</span></pre>

<p>Очевидно, должно быть нечто большее, чем просто библиотеки: <code>#[no_std]</code> можно
использовать с исполняемыми контейнерами, а управлять точкой входа можно двумя
способами: с помощью атрибута <code>#[start]</code>, или с помощью переопределения
прокладки (shim) для C функции <code>main</code> по умолчанию на вашу собственную.</p>

<p>В функцию, помеченную атрибутом <code>#[start]</code>, передаются параметры командной
строки в том же формате, что и в C:</p>
<span class='rusttest'>#![feature(lang_items, start, no_std, libc)]
#![no_std]

// Pull in the system libc library for what crt0.o likely requires
extern crate libc;

// Entry point for this program
#[start]
fn start(_argc: isize, _argv: *const *const u8) -&gt; isize {
    0
}

// These functions and traits are used by the compiler, but not
// for a bare-bones hello world. These are normally
// provided by libstd.
#[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
#[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
#[lang = &quot;panic_fmt&quot;] fn panic_fmt() -&gt; ! { loop {} }
// fn main() {} tricked you, rustdoc!
</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>lang_items</span>, <span class='ident'>start</span>, <span class='ident'>no_std</span>, <span class='ident'>libc</span>)]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>no_std</span>]</span>

<span class='comment'>// Pull in the system libc library for what crt0.o likely requires</span>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>libc</span>;

<span class='comment'>// Entry point for this program</span>
<span class='attribute'>#[<span class='ident'>start</span>]</span>
<span class='kw'>fn</span> <span class='ident'>start</span>(<span class='ident'>_argc</span>: <span class='ident'>isize</span>, <span class='ident'>_argv</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>) <span class='op'>-&gt;</span> <span class='ident'>isize</span> {
    <span class='number'>0</span>
}

<span class='comment'>// These functions and traits are used by the compiler, but not</span>
<span class='comment'>// for a bare-bones hello world. These are normally</span>
<span class='comment'>// provided by libstd.</span>
<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;stack_exhausted&quot;</span>]</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>stack_exhausted</span>() {}
<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;eh_personality&quot;</span>]</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>eh_personality</span>() {}
<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;panic_fmt&quot;</span>]</span> <span class='kw'>fn</span> <span class='ident'>panic_fmt</span>() <span class='op'>-&gt;</span> <span class='op'>!</span> { <span class='kw'>loop</span> {} }</pre>

<p>Чтобы переопределить вставленную компилятором прокладку <code>main</code>, нужно сначала
отключить ее с помощью <code>#![no_main]</code>, а затем создать соответствующий символ с
правильным ABI и правильным именем, что также потребует переопределение
искажения (коверкания) имен компилятором (<code>#[no_mangle]</code>):</p>
<span class='rusttest'>#![feature(no_std)]
#![no_std]
#![no_main]
#![feature(lang_items, start)]

extern crate libc;

#[no_mangle] // для уверенности в том, что этот символ будет называться `main` на выходе
pub extern fn main(argc: i32, argv: *const *const u8) -&gt; i32 {
    0
}

#[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
#[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
#[lang = &quot;panic_fmt&quot;] fn panic_fmt() -&gt; ! { loop {} }
// fn main() {} tricked you, rustdoc!
</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>no_std</span>)]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>no_std</span>]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>no_main</span>]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>lang_items</span>, <span class='ident'>start</span>)]</span>

<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>libc</span>;

<span class='attribute'>#[<span class='ident'>no_mangle</span>]</span> <span class='comment'>// для уверенности в том, что этот символ будет называться `main` на выходе</span>
<span class='kw'>pub</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>main</span>(<span class='ident'>argc</span>: <span class='ident'>i32</span>, <span class='ident'>argv</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u8</span>) <span class='op'>-&gt;</span> <span class='ident'>i32</span> {
    <span class='number'>0</span>
}

<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;stack_exhausted&quot;</span>]</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>stack_exhausted</span>() {}
<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;eh_personality&quot;</span>]</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>eh_personality</span>() {}
<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;panic_fmt&quot;</span>]</span> <span class='kw'>fn</span> <span class='ident'>panic_fmt</span>() <span class='op'>-&gt;</span> <span class='op'>!</span> { <span class='kw'>loop</span> {} }</pre>

<p>В настоящее время компилятор делает определенные предположения о символах,
которые доступны для вызова в исполняемом контейнере. Как правило, эти функции
предоставляются стандартной библиотекой, но если она не используется, то вы
должны определить их самостоятельно.</p>

<p>Первая из этих трех функций, <code>stack_exhausted</code>, вызывается тогда, когда
обнаруживается (происходит) переполнение стека. Эта функция имеет ряд
ограничений, касающихся того, как она может быть вызвана и того, что она должна
делать, но если регистр предела стека не поддерживается, то поток всегда имеет
«бесконечный стек» и эта функция не должна быть вызвана (получить управление,
срабатывать).</p>

<p>Вторая из этих трех функций, <code>eh_personality</code>, используется в механизме
обработки ошибок компилятора. Она часто отображается на функцию personality
(специализации) GCC (для получения дополнительной информации смотри <a href="http://doc.rust-lang.org/std/rt/unwind/index.html">реализацию
libstd</a>), но можно с
уверенностью сказать, что для контейнеров, которые не вызывают панику, эта
функция никогда не будет вызвана. Последняя функция, <code>panic_fmt</code>, также
используются в механизме обработки ошибок компилятора.</p>

<h2 id='Использование-основной-библиотеки-libcore' class='section-header'><a href='#Использование-основной-библиотеки-libcore'>Использование основной библиотеки (libcore)</a></h2>
<blockquote>
<p><strong>Примечание</strong>: структура основной библиотеки (core) является нестабильной, и
поэтому рекомендуется использовать стандартную библиотеку (std) там, где это
возможно.</p>
</blockquote>

<p>С учетом указанных выше методов, у нас есть чисто-металлический исполняемый код
работает Rust. Стандартная библиотека предоставляет немало функциональных
возможностей, однако, для Rust также важна производительность. Если стандартная
библиотека не соответствует этим требованиям, то вместо нее может быть
использована <a href="http://doc.rust-lang.org/core/index.html">libcore</a>.</p>

<p>Основная библиотека имеет очень мало зависимостей и гораздо более компактна, чем
стандартная библиотека. Кроме того, основная библиотека имеет большую часть
необходимой функциональности для написания идиоматического и эффективного кода
на Rust.</p>

<p>В качестве примера приведем программу, которая вычисляет скалярное произведение
двух векторов, предоставленных из кода C, и использует идиоматические практики
Rust.</p>
<span class='rusttest'>#![feature(lang_items, start, no_std, core, libc)]
#![no_std]

extern crate libc;
extern crate core;

use core::prelude::*;

use core::mem;

#[no_mangle]
pub extern fn dot_product(a: *const u32, a_len: u32,
                          b: *const u32, b_len: u32) -&gt; u32 {
    use core::raw::Slice;

    // Convert the provided arrays into Rust slices.
    // The core::raw module guarantees that the Slice
    // structure has the same memory layout as a &amp;[T]
    // slice.
    //
    // This is an unsafe operation because the compiler
    // cannot tell the pointers are valid.
    let (a_slice, b_slice): (&amp;[u32], &amp;[u32]) = unsafe {
        mem::transmute((
            Slice { data: a, len: a_len as usize },
            Slice { data: b, len: b_len as usize },
        ))
    };

    // Iterate over the slices, collecting the result
    let mut ret = 0;
    for (i, j) in a_slice.iter().zip(b_slice.iter()) {
        ret += (*i) * (*j);
    }
    return ret;
}

#[lang = &quot;panic_fmt&quot;]
extern fn panic_fmt(args: &amp;core::fmt::Arguments,
                    file: &amp;str,
                    line: u32) -&gt; ! {
    loop {}
}

#[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
#[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
#[start] fn start(argc: isize, argv: *const *const u8) -&gt; isize { 0 }
fn main() {}
</span><pre class='rust rust-example-rendered'>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>feature</span>(<span class='ident'>lang_items</span>, <span class='ident'>start</span>, <span class='ident'>no_std</span>, <span class='ident'>core</span>, <span class='ident'>libc</span>)]</span>
<span class='attribute'>#<span class='op'>!</span>[<span class='ident'>no_std</span>]</span>

<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>core</span>;

<span class='kw'>use</span> <span class='ident'>core</span>::<span class='ident'>prelude</span>::<span class='op'>*</span>;

<span class='kw'>use</span> <span class='ident'>core</span>::<span class='ident'>mem</span>;

<span class='attribute'>#[<span class='ident'>no_mangle</span>]</span>
<span class='kw'>pub</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>dot_product</span>(<span class='ident'>a</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u32</span>, <span class='ident'>a_len</span>: <span class='ident'>u32</span>,
                          <span class='ident'>b</span>: <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>u32</span>, <span class='ident'>b_len</span>: <span class='ident'>u32</span>) <span class='op'>-&gt;</span> <span class='ident'>u32</span> {
    <span class='kw'>use</span> <span class='ident'>core</span>::<span class='ident'>raw</span>::<span class='ident'>Slice</span>;

    <span class='comment'>// Convert the provided arrays into Rust slices.</span>
    <span class='comment'>// The core::raw module guarantees that the Slice</span>
    <span class='comment'>// structure has the same memory layout as a &amp;[T]</span>
    <span class='comment'>// slice.</span>
    <span class='comment'>//</span>
    <span class='comment'>// This is an unsafe operation because the compiler</span>
    <span class='comment'>// cannot tell the pointers are valid.</span>
    <span class='kw'>let</span> (<span class='ident'>a_slice</span>, <span class='ident'>b_slice</span>): (<span class='kw-2'>&amp;</span>[<span class='ident'>u32</span>], <span class='kw-2'>&amp;</span>[<span class='ident'>u32</span>]) <span class='op'>=</span> <span class='kw'>unsafe</span> {
        <span class='ident'>mem</span>::<span class='ident'>transmute</span>((
            <span class='ident'>Slice</span> { <span class='ident'>data</span>: <span class='ident'>a</span>, <span class='ident'>len</span>: <span class='ident'>a_len</span> <span class='kw'>as</span> <span class='ident'>usize</span> },
            <span class='ident'>Slice</span> { <span class='ident'>data</span>: <span class='ident'>b</span>, <span class='ident'>len</span>: <span class='ident'>b_len</span> <span class='kw'>as</span> <span class='ident'>usize</span> },
        ))
    };

    <span class='comment'>// Iterate over the slices, collecting the result</span>
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>ret</span> <span class='op'>=</span> <span class='number'>0</span>;
    <span class='kw'>for</span> (<span class='ident'>i</span>, <span class='ident'>j</span>) <span class='kw'>in</span> <span class='ident'>a_slice</span>.<span class='ident'>iter</span>().<span class='ident'>zip</span>(<span class='ident'>b_slice</span>.<span class='ident'>iter</span>()) {
        <span class='ident'>ret</span> <span class='op'>+=</span> (<span class='op'>*</span><span class='ident'>i</span>) <span class='op'>*</span> (<span class='op'>*</span><span class='ident'>j</span>);
    }
    <span class='kw'>return</span> <span class='ident'>ret</span>;
}

<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;panic_fmt&quot;</span>]</span>
<span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>panic_fmt</span>(<span class='ident'>args</span>: <span class='kw-2'>&amp;</span><span class='ident'>core</span>::<span class='ident'>fmt</span>::<span class='ident'>Arguments</span>,
                    <span class='ident'>file</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>,
                    <span class='ident'>line</span>: <span class='ident'>u32</span>) <span class='op'>-&gt;</span> <span class='op'>!</span> {
    <span class='kw'>loop</span> {}
}

<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;stack_exhausted&quot;</span>]</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>stack_exhausted</span>() {}
<span class='attribute'>#[<span class='ident'>lang</span> <span class='op'>=</span> <span class='string'>&quot;eh_personality&quot;</span>]</span> <span class='kw'>extern</span> <span class='kw'>fn</span> <span class='ident'>eh_personality</span>() {}</pre>

<p>Обратите внимание, что здесь, в отличае от примеров, рассмотренных выше, есть
один дополнительный lang элемент <code>panic_fmt</code>. Он должен быть определён
потребителями libcore, потому что основная библиотека объявляет панику, но не
определяет её. lang элемент <code>panic_fmt</code> определяет панику для этого
контейнера, и необходимо гарантировать, что он никогда не возвращает значение.</p>

<p>Как видно в этом примере, основная библиотека предназначена для предоставления
всей мощи Rust при любых обстоятельствах, независимо от требований платформы.
Дополнительные библиотеки, такие как liballoc, добавляют функциональность для
libcore, для работы которой нужно сделать некоторые платформо-зависимые
предположения; но эти библиотеки всё равно более переносимы, чем стандартная
библиотека в целом.</p>

    <script type="text/javascript">
        window.playgroundUrl = "http://play.rust-lang.org";
    </script>
    
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
  document.getElementById("toggle-nav").onclick = toggleNav;
  function toggleNav() {
    var toc = document.getElementById("toc");
    var pagewrapper = document.getElementById("page-wrapper");
    toggleClass(toc, "mobile-hidden");
    toggleClass(pagewrapper, "mobile-hidden");
  };

  function toggleClass(el, className) {
     // from http://youmightnotneedjquery.com/
     if (el.classList) {
       el.classList.toggle(className);
     } else {
       var classes = el.className.split(' ');
       var existingIndex = classes.indexOf(className);

       if (existingIndex >= 0) {
         classes.splice(existingIndex, 1);
       } else {
         classes.push(className);
       }

       el.className = classes.join(' ');
     }
  }

  // The below code is used to add prev and next navigation links to the bottom
  // of each of the sections.
  // It works by extracting the current page based on the url and iterates over
  // the menu links until it finds the menu item for the current page. We then
  // create a copy of the preceding and following menu links and add the
  // correct css class and insert them into the bottom of the page.
  var toc = document.getElementById('toc').getElementsByTagName('a');
  var href = document.location.pathname.split('/').pop();
  if (href === 'index.html' || href === '') {
    href = 'README.html';
  }

  for (var i = 0; i < toc.length; i++) {
    if (toc[i].attributes['href'].value.split('/').pop() === href) {
      var nav = document.createElement('p');
      if (i > 0) {
        var prevNode = toc[i-1].cloneNode(true);
        prevNode.className = 'left';
        nav.appendChild(prevNode);
      }
      if (i < toc.length - 1) {
        var nextNode = toc[i+1].cloneNode(true);
        nextNode.className = 'right';
        nav.appendChild(nextNode);
      }
      document.getElementById('page').appendChild(nav);
      break;
    }
  }

});
</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="playpen.js"></script>
</div></div>


</body>
</html>